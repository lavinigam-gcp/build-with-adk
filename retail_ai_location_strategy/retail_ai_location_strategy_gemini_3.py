# -*- coding: utf-8 -*-
"""retail_ai_location_strategy_gemini_3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/GoogleCloudPlatform/generative-ai/blob/main/gemini/use-cases/retail/retail_ai_location_strategy_gemini_3.ipynb
"""

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""# Retail AI Location Strategy: Autonomous Site Selection & Market Analysis

<table align="left">
  <td style="text-align: center">
    <a href="https://colab.research.google.com/github/GoogleCloudPlatform/generative-ai/blob/main/gemini/use-cases/retail/retail_ai_location_strategy_gemini_3.ipynb">
      <img width="32px" src="https://www.gstatic.com/pantheon/images/bigquery/welcome_page/colab-logo.svg" alt="Google Colaboratory logo"><br> Open in Colab
    </a>
  </td>
  <td style="text-align: center">
    <a href="https://console.cloud.google.com/vertex-ai/colab/import/https:%2F%2Fraw.githubusercontent.com%2FGoogleCloudPlatform%2Fgenerative-ai%2Fmain%2Fgemini%2Fuse-cases%2Fretail%2Fretail_ai_location_strategy_gemini_3.ipynb">
      <img width="32px" src="https://lh3.googleusercontent.com/JmcxdQi-qOpctIvWKgPtrzZdJJK-J3sWE1RsfjZNwshCFgE_9fULcNpuXYTilIR2hjwN" alt="Google Cloud Colab Enterprise logo"><br> Open in Colab Enterprise
    </a>
  </td>
  <td style="text-align: center">
    <a href="https://console.cloud.google.com/vertex-ai/workbench/deploy-notebook?download_url=https://raw.githubusercontent.com/GoogleCloudPlatform/generative-ai/main/gemini/use-cases/retail/retail_ai_location_strategy_gemini_3.ipynb">
      <img src="https://www.gstatic.com/images/branding/gcpiconscolors/vertexai/v1/32px.svg" alt="Vertex AI logo"><br> Open in Vertex AI Workbench
    </a>
  </td>
  <td style="text-align: center">
    <a href="https://github.com/GoogleCloudPlatform/generative-ai/blob/main/gemini/use-cases/retail/retail_ai_location_strategy_gemini_3.ipynb">
      <img width="32px" src="https://raw.githubusercontent.com/primer/octicons/refs/heads/main/icons/mark-github-24.svg" alt="GitHub logo"><br> View on GitHub
    </a>
  </td>
</table>

<div style="clear: both;"></div>

<p>
<b>Share to:</b>

<a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A//github.com/GoogleCloudPlatform/generative-ai/blob/main/gemini/use-cases/retail/retail_ai_location_strategy_gemini_3.ipynb" target="_blank">
  <img width="20px" src="https://upload.wikimedia.org/wikipedia/commons/8/81/LinkedIn_icon.svg" alt="LinkedIn logo">
</a>

<a href="https://bsky.app/intent/compose?text=https%3A//github.com/GoogleCloudPlatform/generative-ai/blob/main/gemini/use-cases/retail/retail_ai_location_strategy_gemini_3.ipynb" target="_blank">
  <img width="20px" src="https://upload.wikimedia.org/wikipedia/commons/7/7a/Bluesky_Logo.svg" alt="Bluesky logo">
</a>

<a href="https://twitter.com/intent/tweet?url=https%3A//github.com/GoogleCloudPlatform/generative-ai/blob/main/gemini/use-cases/retail/retail_ai_location_strategy_gemini_3.ipynb" target="_blank">
  <img width="20px" src="https://upload.wikimedia.org/wikipedia/commons/5/5a/X_icon_2.svg" alt="X logo">
</a>

<a href="https://reddit.com/submit?url=https%3A//github.com/GoogleCloudPlatform/generative-ai/blob/main/gemini/use-cases/retail/retail_ai_location_strategy_gemini_3.ipynb" target="_blank">
  <img width="20px" src="https://redditinc.com/hubfs/Reddit%20Inc/Brand/Reddit_Logo.png" alt="Reddit logo">
</a>

<a href="https://www.facebook.com/sharer/sharer.php?u=https%3A//github.com/GoogleCloudPlatform/generative-ai/blob/main/gemini/use-cases/retail/retail_ai_location_strategy_gemini_3.ipynb" target="_blank">
  <img width="20px" src="https://upload.wikimedia.org/wikipedia/commons/5/51/Facebook_f_logo_%282019%29.svg" alt="Facebook logo">
</a>
</p>

| Authors |
| --- |
| [Deepak Moonat](https://github.com/dmoonat) |
| [Lavi Nigam](https://github.com/lavinigam-gcp) |

## Overview

**Gemini 3** is Google's latest flagship model family, trained to be especially proficient in:

* **Advanced reasoning and complex instruction following**  
* **Agentic operations and autonomous code execution**  
* **Multimodal understanding across long contexts** (text, image, audio, video)


In this notebook, we will explore **Gemini 3**, capable of performing complex market research.

### The Business Problem: The "Synthesis Bottleneck"
Opening a physical retail location (e.g., a caf√©, gym, or boutique) is a high-stakes investment often plagued by a lack of unified data.
*   **The Data Fragmentation:** Demographics are on Wikipedia, competitors are on Google Search/Maps, rent trends are in news articles, and math needs to be done in spreadsheets.
*   **The Latency:** Validating a single location typically takes an analyst 1-2 weeks of manual research.
*   **The Risk:** Decisions are often made on "gut feeling" rather than data, leading to a high failure rate for new brick-and-mortar businesses.

**The Solution:** An AI pipeline that unifies these disparate data sources into a coherent strategy in minutes, not weeks.

### Real-World Scenario
Imagine you are the **Chief Strategy Officer** for a retail chain. You have identified a city (e.g., "Bangalore"), but you need to know the *exact* micro-market strategy.

You need an intelligent assistant that can:
1.  **Validate** if the market is growing (requires live web data).
2.  **Locate** every competitor on a map (requires Places APIs).
3.  **Calculate** saturation density (requires Python code).
4.  **Recommend** a specific strategy based on the data (requires reasoning).
5.  **Present** the findings to the board (requires coding HTML).



---


### The Architecture: Why Gemini 3?
This notebook demonstrates how to chain five distinct capabilities of Gemini 3 to solve this problem. We aren't just asking the model to "write text"; we are asking it to use tools to interact with the real world.

| Stage | The Challenge | The Gemini 3 Solution |
| :--- | :--- | :--- |
| **1. Research** | LLMs have a knowledge cutoff. They don't know today's rent trends. | **Search Grounding:** Allows the model to fetch live, verifiable data from the web. |
| **2A. Mapping** | LLMs hallucinate addresses and physical locations. | **Function Calling:** The model autonomously queries the **Google Maps Places API** for ground-truth data. |
| **2B. Analysis** | LLMs are poor at complex arithmetic and density calculations. | **Code Execution:** The model writes and runs **Python code** to perform precise data science on the fly. |
| **3. Strategy** | Raw data doesn't equal insight. We need "Executive Reasoning." | **Thinking Mode:** Uses extended reasoning to weigh pros/cons and produce structured JSON decisions. |
| **4. Reporting** | Text is boring. Stakeholders need visual slides. | **Code Generation:** The model designs a high-fidelity, multi-slide **HTML/CSS report** from scratch. |

---

### System Flow

![](https://storage.googleapis.com/github-repo/generative-ai/gemini3/assets/location_finder_01.png)


---

### Learning Objectives

By the end of this notebook, you will understand how to architect sophisticated setup using Gemini 3. Specifically, you will learn to:

*   **Architect Multi-stage Workflows:** Move beyond single-turn prompts to build a multi-stage pipeline where the model maintains context across research, analysis, and decision-making phases.
*   **Orchestrate Multi-Modal Tools:** Apply the integration of **Search Grounding** (for fresh data), **Function Calling** (for Maps interaction), and **Code Execution** (for computation) within a single session.
*   **Implement Hybrid Grounding:** Solve the "hallucination problem" by forcing the model to base its reasoning on retrieved real-world data (Google Maps) and verified web sources.
*   **Leverage Extended Reasoning:** Use Gemini 3's advanced thinking capabilities to produce structured, strategic outputs (JSON) suitable for enterprise downstream applications.
*   **Autonomous Asset Generation:** Direct the model to act as a full-stack developer, autonomously generating and styling professional HTML reports to visualize your findings.

## Setup

### Prerequisites

**Required:**
- Python 3.9 or higher
- Google Cloud project with Vertex AI API enabled
- Google Maps API key (Places APIs)
- Completed [Intro to Gemini 3 Pro](https://github.com/GoogleCloudPlatform/generative-ai/blob/main/gemini/getting-started/intro_gemini_3_pro.ipynb) (L100 tutorial)

**Helpful:**
- Familiarity with Jupyter notebooks
- Basic understanding of AI concepts

### Installation
"""

# Commented out IPython magic to ensure Python compatibility.
# Install required packages
# %pip install --upgrade --quiet \
    google-genai \
    googlemaps

"""### Authenticate (Colab Only)"""

import sys

# Authenticate if running on Colab
if "google.colab" in sys.modules:
    from google.colab import auth

    auth.authenticate_user()

"""### Set Up Google Cloud Project"""

import os

# Configure your Google Cloud project
# fmt: off
PROJECT_ID = "[your-project-id]"  # @param {type: "string", placeholder: "[your-project-id]", isTemplate: true}
# fmt: on

if not PROJECT_ID or PROJECT_ID == "[your-project-id]":
    PROJECT_ID = str(os.environ.get("GOOGLE_CLOUD_PROJECT"))

if not PROJECT_ID:
    raise ValueError("Please set PROJECT_ID to your Google Cloud project ID")

LOCATION = "global"  # Gemini 3 is available globally

print(f"‚úÖ Using project: {PROJECT_ID}")
print(f"‚úÖ Using location: {LOCATION}")

"""### Set Up Google Maps API Key

**First, enable the Maps Places API in your Google Cloud Console:**
[Maps Places API](https://console.cloud.google.com/apis/api/places-backend.googleapis.com/overview)


Once you've enable the relevant Google Maps APIs, you can [generate a Maps API key](https://developers.google.com/maps/documentation/geocoding/get-api-key)
"""

# For Colab: Store API key in Colab Secrets
# [Left panel, look for a key icon] Secrets ‚Üí Add MAPS_API_KEY

if "google.colab" in sys.modules:
    from google.colab import userdata

    MAPS_API_KEY = userdata.get("MAPS_API_KEY")
else:
    # For local/production: Use environment variable
    MAPS_API_KEY = os.environ.get("MAPS_API_KEY")

if not MAPS_API_KEY:
    raise ValueError(
        "Please set MAPS_API_KEY:\n"
        "  Colab: Add to Secrets (Settings ‚Üí Secrets)\n"
        "  Local: export MAPS_API_KEY=your_api_key"
    )

print("‚úÖ Maps API key configured")

"""### Import Libraries"""

# Standard libraries
import datetime
import json
import os
import sys
import warnings

# Suppress all warnings from the google.genai module
warnings.filterwarnings("ignore", module="google.genai")


# Display libraries
from IPython.display import HTML, Image, Markdown, display

# Google Gen AI SDK
from google import genai
from google.genai import types

# For structured output
from pydantic import BaseModel

print("‚úÖ All libraries imported successfully")

"""### Initialize Gemini Client"""

# Initialize the Gemini client
client = genai.Client(vertexai=True, project=PROJECT_ID, location=LOCATION)

# Set the model
MODEL_ID = "gemini-3-pro-preview"

print("‚úÖ Gemini client initialized")
print(f"‚úÖ Using model: {MODEL_ID}")

"""## Configure Your Analysis

### Set Your Location and Business Type
"""

print("=" * 70)
print("SMART LOCATION FINDER - CONFIGURATION")
print("=" * 70)

# Configure your analysis parameters
# You can change these to analyze any location worldwide!

# Target location (city or area)
# Examples:
#   - "Whitefield, Bangalore, India"
#   - "Austin, Texas, USA"
#   - "Shibuya, Tokyo, Japan"
#   - "Shoreditch, London, UK"
TARGET_LOCATION = "KR Puram, Bangalore, India"  # @param {type: "string"}

# Business type you want to open
# Examples:
#   - "specialty coffee shop"
#   - "fitness studio"
#   - "fast-casual restaurant"
#   - "bookstore cafe"
BUSINESS_TYPE = "fitness studio"  # @param {type: "string"}

# Display configuration
print(f"\nüìç Target Location: {TARGET_LOCATION}")
print(f"üè™ Business Type: {BUSINESS_TYPE}")

print("\n" + "=" * 70)
print("Configuration complete! Starting analysis...")
print("=" * 70)

"""**Note:** You can change these parameters to analyze any location in the world. The notebook will adapt all prompts and analysis to your specific inputs.

## PART 1: Market Research

![](https://storage.googleapis.com/github-repo/generative-ai/gemini3/assets/location_finder_02.png)

### The Goal: "Macro" Viability Assessment
Referring back to our System Flow, we are starting at the **Data Gathering** phase. Before we zoom into specific streets or buildings, we must validate the **Macro-Economic Environment**.

Our first objective is to answer: *"Is this location economically viable for this specific business type right now?"*

### The Technical Challenge: The Knowledge Cutoff
If we asked a standard LLM, *"What are the commercial rental trends in KR Puram?"*, it relies on training data that might be 6‚Äì12 months old **(Gemini 3 has a knowledge cutoff date of Jan'2025)**. In the fast-moving retail world, old data is dangerous. It might miss:
*   A new metro station that opened last month (increasing foot traffic).
*   A recent spike in commercial rents.
*   New demographic shifts (e.g., a new tech park bringing in young professionals).

### The Solution: Gemini 3 with Search Grounding
To solve this, we activate **Search Grounding**. This connects the model to Google Search, allowing it to:
1.  **Query** live web sources for real-time demographics and news.
2.  **Retrieve** current economic indicators.
3.  **Synthesize** disparate information (census data + news articles + real estate listings) into a coherent analyst report.

**What we will do:**
We will construct a prompt that acts as a "Market Research Analyst," specifically requesting data on **Demographics**, **Market Growth**, and **Commercial Viability**. Notice how the system instruction enforces factual, data-driven responses.
"""

# get current date
CURRENT_DATE = datetime.datetime.now().strftime("%Y-%m-%d")

print("=" * 70)
print("PART 1: MARKET RESEARCH")
print("=" * 70)

# Define system instruction
system_instruction = """
You are a market research analyst specializing in retail location intelligence.

Your task is to research and validate target markets for new business locations.

Use Google Search to find:
- Current demographics (age, income, population)
- Market trends and growth patterns
- Industry-specific insights
- Commercial real estate trends

Provide specific data points with sources. Be factual and data-driven.
"""

# Define the research prompt
market_research_prompt = f"""
Research {TARGET_LOCATION} as a market for opening a {BUSINESS_TYPE}.

Focus on:

1. DEMOGRAPHICS:
   - Age distribution (identify key age groups)
   - Income levels and purchasing power
   - Lifestyle indicators (professionals, students, families)
   - Population density

2. MARKET GROWTH:
   - Population trends (growing, stable, declining)
   - New residential and commercial developments
   - Infrastructure improvements
   - Economic growth indicators

3. INDUSTRY PRESENCE:
   - Existing similar businesses in the area
   - Consumer preferences and spending patterns
   - Market saturation or opportunity

4. COMMERCIAL VIABILITY:
   - Foot traffic patterns
   - Commercial real estate trends
   - Typical rental costs (qualitative: low/medium/high)
   - Business environment

Provide specific data points (percentages, trends, indicators) with sources.
Conclude with: Is this a strong market for {BUSINESS_TYPE}? Why or why not?

Current date: {CURRENT_DATE}
"""

# Enable Google Search grounding
search_tool = types.Tool(google_search=types.GoogleSearch())

# Generate market research
print(f"\nüîç Researching {TARGET_LOCATION} market for {BUSINESS_TYPE}...")

response = client.models.generate_content(
    model=MODEL_ID,
    contents=market_research_prompt,
    config=types.GenerateContentConfig(
        system_instruction=system_instruction, tools=[search_tool]
    ),
)

# Display the research findings
display(Markdown("## Market Research Findings"))
display(Markdown(response.text))

# Display search sources
if response.candidates[0].grounding_metadata:
    display(Markdown("\n## Sources"))
    display(
        HTML(
            response.candidates[
                0
            ].grounding_metadata.search_entry_point.rendered_content
        )
    )

# Save for later parts
market_research_findings = response.text

print("\n‚úÖ Market research complete and saved for next parts")

"""### üîç Analysis of the Output

**What just happened?**
The model executed a real-time research task, adeptly connecting unprocessed web information with meaningful strategic understanding.

**Key Observations for the Architect:**
1.  **Freshness of Data:** Notice the references to current infrastructure (e.g., specific metro lines, new housing developments) or current rental price ranges (e.g., "‚Çπ40 ‚Äì ‚Çπ65 per sq. ft"). This is data the base model likely did not have in its frozen weights.
2.  **Synthesis:** It combined *Demographic Data* (Age/Income) with *Infrastructure Data* (Traffic/Metro) to form a *Business Conclusion* (e.g., "Avoid the junction, target the residential interior").
3.  **The "Go/No-Go" Signal:** The report concludes with a validated "YES/NO" on market strength.

**Connecting to the Next Step:**
We now have the **"Why"** (The market is strong because of X, Y, Z).
But we still lack the **"Where"**.
The report might say "competition is high," but it doesn't tell us *exactly* where those competitors are located on a map. To make a strategic decision, we need precise coordinates, not just general trends.

This leads us directly to **Part 2A**, where we will switch tools from *Search* to *Maps* to plot the physical battlefield.

## PART 2A: Competitor Mapping

![](https://storage.googleapis.com/github-repo/generative-ai/gemini3/assets/location_finder_03.png)

### The Goal: "Micro" Competitive Intelligence
In Part 1, we validated that the *macro* market is strong. Now, we zoom in. To open a successful physical business, you need to know exactly who you are fighting against.
We need to answer: *"Where exactly are my competitors located, and are they any good?"*

### The Technical Challenge: The Hallucination Trap
If we simply asked an LLM, *"List all gyms in KR Puram with their addresses,"* it would likely invent plausible-sounding names ("KR Puram Fitness Center") or give outdated addresses.
**An LLM is a reasoning engine, not a database.** It does not have a live map of the world in its memory.

### The Solution: Function Calling + Google Maps API
To get ground-truth data, we use **Function Calling**. This capability allows Gemini 3 to "realize" it needs external data and autonomously execute a programming function to get it.

**The Architecture:**
1.  **We provide a tool:** We give Gemini a Python function (`search_places`) that wraps the Google Maps Places API.
2.  **Gemini acts as the agent:** We don't run the function ourselves. We just tell Gemini, "Find the competitors."
3.  **Autonomous Execution:** Gemini analyzes the prompt, understands it needs the tool, generates the correct API query (e.g., "fitness studio in KR Puram"), executes the call, and interprets the JSON result.

**What we will do:**
We will first define the `search_places` function. Then, we will prompt Gemini to use this function to build a comprehensive **Competitor Map**, analyzing clustering patterns, quality gaps (ratings), and saturation levels.

### Step 1: Define the Search Function
"""

print("=" * 70)
print("PART 2: COMPETITOR MAPPING")
print("=" * 70)


def search_places(query: str):
    """Search for places using the Google Maps Places API."""
    import googlemaps

    gmaps = googlemaps.Client(key=MAPS_API_KEY)
    return gmaps.places(query)


# Test the function
print(f"\nüß™ Testing search function for {BUSINESS_TYPE} near {TARGET_LOCATION}...")
test_query = f"{BUSINESS_TYPE} near {TARGET_LOCATION}"
test_result = search_places(query=test_query)
print(f"‚úÖ Function works! Found {len(test_result.get('results', []))} results")
if test_result.get("results"):
    print(f"   Sample: {test_result['results'][0]['name']}")

"""### Step 2: Use Function Calling with Gemini

![](https://storage.googleapis.com/github-repo/generative-ai/gemini3/assets/location_finder_06.png)
"""

# Define system instruction for competitive analysis
system_instruction = """
You are a market intelligence analyst specializing in competitive landscape analysis.

You have access to the search_places() function which uses Google Maps to find competing businesses in a specific area.

When analyzing competition:
1. Use the function to get REAL data about existing competitors
2. Analyze the distribution (clustered vs spread out)
3. Identify patterns in location types (malls, main roads, residential areas)
4. Note gaps or underserved areas
5. Assess market saturation

Be specific with the data you receive. Reference actual business names, locations, and ratings.
"""

# Prompt for competitor analysis
competitor_prompt = f"""
Find all competitors for a {BUSINESS_TYPE} in {TARGET_LOCATION}.

Use the search_places function to get real data from Google Maps.

After getting the results:
1. List the competitors found (name, location, rating)
2. Identify any patterns:
   - Are they clustered in specific areas/zones?
   - What types of locations (shopping areas, main roads, residential)?
3. Categorize them if applicable:
   - Premium vs budget
   - High-rated (4.5+) vs others
   - Chain vs independent
4. Initial assessment:
   - Which areas seem saturated?
   - Which areas might be underserved?

Be specific and reference the actual data you receive.

Current date: {CURRENT_DATE}
"""


# Generate content with function calling enabled
print(f"\nüó∫Ô∏è Mapping competitors in {TARGET_LOCATION} using Maps Places API...")

# Send the prompt - model will automatically call the function
response = client.models.generate_content(
    model=MODEL_ID,
    contents=competitor_prompt,
    config=types.GenerateContentConfig(
        system_instruction=system_instruction, tools=[search_places]
    ),
)

# Display the analysis
display(Markdown("## Competitor Analysis"))
display(Markdown(response.text))

# Show what function was called
print("\nüìã Function Call Details:")
for turn in response.automatic_function_calling_history:
    for part in turn.parts:
        if part.function_call:
            print(f"   Called: {part.function_call.name}")
            print(f"   Arguments: {part.function_call.args}")

# Save for later parts
competitor_analysis = response.text

print("\n‚úÖ Competitor mapping complete and saved for next parts")

"""### Recommended

- Use `Grounding with Google Maps`, to ground your model's responses, enabling your AI applications to provide local data and geospatial context.
- Wrap the Google Maps as a tool, and provide it as a model config
- Check out the [documentation](https://docs.cloud.google.com/vertex-ai/generative-ai/docs/grounding/grounding-with-google-maps) for more details

```
# Enable Google Maps grounding
maps_tool = types.Tool(google_maps=types.GoogleMaps())
```

**Note:** Use built-in Grounding with Google Maps for simple, conversational applications where you want to automatically add location awareness with minimal code ( source). Use Custom Tools for complex, agentic workflows that require precise control and structured data to pass between different analysis steps. So depending on the use-case one can make a choice.

### üó∫Ô∏è Analysis of the Output

**What just happened?**
This was a demonstration of **Automatic Function Calling**.

1. **Autonomous Tool Use:** Look at the Function Call Details at the bottom of the output. You didn't have to write the specific query for the tool. The model generated the necessary arguments (e.g., combining the business type and location) dynamically based on your high-level instruction.
2.  **Real-World Data:** The list of competitors and their details (e.g., names, ratings) represents real-world businesses with verifiable data. This is not just generated text; it is structured data retrieved from a reliable external source.
3.  **Strategic Clustering:** The model didn't just provide a simple list; it analyzed geographical patterns in the data. It can identify and label different zones, such as 'Primary Clusters' where competition is dense, and 'Emerging Clusters' where there might be an opportunity. This requires **spatial reasoning capability**.

**Connecting to the Next Step:**
We now have two critical pieces of the puzzle:
1.  **Market Context (Part 1):** The area is growing and needs premium services.
2.  **Competitor Map (Part 2A):** The main roads are saturated, but quality gaps exist.

However, "saturation" is currently just a *feeling* based on looking at a list. To make a multimillion-dollar investment decision, we need **Math**, not feelings. We need to calculate density scores and quantify the opportunity.
Gemini is great at words, but can it do data science?
In **Part 2B**, we will hand these datasets to a **Code Execution** engine to perform rigorous gap analysis.

## PART 2B: Gap Analysis with Code Execution

![](https://storage.googleapis.com/github-repo/generative-ai/gemini3/assets/location_finder_03.png)

### The Goal: Quantitative "White Space" Analysis
We have a validated market (Part 1) and a list of competitors (Part 2A). A human analyst would now open Excel to calculate density, saturation, and projected revenue.
We need to answer: *"Which specific zone offers the highest reward for the lowest risk?"*

### The Technical Challenge: The "Math" Problem
Large Language Models (LLMs) are designed for language, not logic. If you ask an LLM to "calculate the saturation index of 5 zones based on weighted averages," it might give you a plausible-looking number that is mathematically wrong.
**For business strategy, we cannot afford "hallucinated math."**

### The Solution: Code Execution (Python)
Gemini 3 overcomes this by writing and executing **real Python code**. It doesn't guess the answer; it *computes* it.

**The Architecture:**
1.  **Data Ingestion:** We feed the unstructured text from Part 1 and Part 2B into the prompt.
2.  **Code Generation:** Gemini writes a Python script using `pandas` and `numpy`. It structures the data into a DataFrame.
3.  **Algorithmic Logic:** It implements complex custom metrics:
    *   **Saturation Index:** `(Competitors √ó Quality Score) / Demand Signal`
    *   **Viability Score:** A weighted ranking of all zones.
4.  **Execution:** The code runs in a secure sandbox, and the *actual* output (the calculated table) is returned.

**What we will do:**
We will instruct Gemini to act as a Data Scientist. It will parse our previous findings, define zones, assign scores, and calculate a "Viability Matrix" to objectively rank the best locations.

![](https://storage.googleapis.com/github-repo/generative-ai/gemini3/assets/location_finder_07.png)
"""

print("=" * 70)
print("PART 2B: GAP ANALYSIS")
print("=" * 70)

# Enhanced prompt with context from Parts 1 & 2
gap_analysis_prompt = f"""
You have conducted comprehensive research. Here is the COMPLETE CONTEXT:

**MARKET RESEARCH FINDINGS (Part 1):**
{market_research_findings}

**COMPETITOR ANALYSIS (Part 2):**
{competitor_analysis}

Based on this REAL data for {BUSINESS_TYPE} in {TARGET_LOCATION}, perform an ADVANCED gap analysis.

Write Python code to:

1. PARSE REAL COMPETITOR DATA FROM PART 2:
   Extract ALL competitors mentioned with their:
   - Names
   - Zones/locations
   - Ratings
   - Type (Chain/Boutique/Quick-Service based on description)

2. EXTRACT MARKET FUNDAMENTALS FROM PART 1:
   - Total population
   - Population density
   - Average income level
   - Rental cost tier (High/Medium/Low)
   - Key infrastructure (Metro stations, malls, tech parks mentioned)
   - Foot traffic patterns

3. CALCULATE ADVANCED METRICS PER ZONE:
   a) Basic metrics:
      - Competitor count
      - Competitor density (per sq km)
      - Average competitor rating

   b) Quality metrics:
      - Competition Quality Score: Weight competitors by rating (4.5+ rated = higher threat)
      - Chain Dominance Ratio: Percentage of big chains (Starbucks, Third Wave, etc.)
      - High-Performer Count: Competitors rated 4.5+

   c) Market opportunity metrics:
      - Demand Signal: Score based on population density, income, infrastructure from Part 1
      - Market Saturation Index: (Competitors √ó Quality Score) / Demand Signal
      - Cost Tier: Estimated rental cost tier (High/Medium/Low based on Part 1)

   d) Strategic scores:
      - Infrastructure Score: Proximity to Metro/malls/tech parks mentioned in Part 1
      - Customer Stickiness: Residential zones (repeat customers) vs Transit zones
      - First-Mover Advantage: New infrastructure with low competition

4. CATEGORIZE ZONES WITH STRATEGIC INSIGHT:
   Not just SATURATED/MODERATE/OPPORTUNITY, but also:
   - Opportunity TYPE: "Underserved Premium", "Metro First-Mover", "Residential Sticky", "Weekend Destination"
   - Risk Level: Based on competition quality and chain dominance (Low/Medium/High)
   - Investment Tier: Based on rental costs from Part 1 (High/Medium/Low)
   - Best Customer Segment: Weekday corporate, weekend residential, WFH crowd, etc.

5. RANK TOP 3 ZONES:
   Use multi-factor scoring:
   - Low competition density
   - Low market saturation
   - High demand signals (income, population, foot traffic)
   - Strategic advantages (Metro proximity, low chain dominance)
   - Manageable costs

6. CREATE COMPREHENSIVE TABLE:
   Show all zones with: competitors, density, quality score, saturation index,
   opportunity type, risk level, investment tier, recommended customer segment

Execute the code and provide ACTIONABLE, STRATEGIC recommendations.
Be specific about WHY each zone is an opportunity or risk.

Current date: {CURRENT_DATE}
"""

# Add code execution tool
code_execution_tool = types.Tool(code_execution=types.ToolCodeExecution())

# Generate analysis with code execution
print(
    f"\nüìä Analyzing competitor density and market opportunities in {TARGET_LOCATION}..."
)
print("   Using real data from Parts 1 & 2 for comprehensive analysis...")

response = client.models.generate_content(
    model=MODEL_ID,
    contents=gap_analysis_prompt,
    config=types.GenerateContentConfig(tools=[code_execution_tool]),
)

# Display the analysis
display(Markdown("## Gap Analysis"))
display(Markdown(response.text))

# Display generated code if available
if response.executable_code:
    display(Markdown("\n### Generated Python Code"))
    display(Markdown(f"```python\n{response.executable_code}\n```"))

    display(Markdown("\n### Code Output"))
    display(Markdown(f"```\n{response.code_execution_result}\n```"))

# Save for Part 4
gap_analysis = response.text

print("\n‚úÖ Gap analysis complete and saved for final recommendation")

"""### üìä Analysis of the Output

**What just happened?**
This is the most powerful demonstration of **Neuro-Symbolic AI** (combining neural networks with symbolic logic/code).

**Key Observations:**
1.  **Structured Thinking:** Look at the **Strategic Zone Ranking Table** in the output. Gemini autonomously created columns for *Risk Level*, *Investment Tier*, and *Viability Score*. It didn't just list zones; it created a quantitative model to evaluate and compare them.
2.  The "Blue Ocean" Finding: This analysis can uncover "Blue Ocean" opportunities‚Äîareas with high demand but low competition. The generated Python code can identify a top-ranked zone by finding a high 'Demand' score coupled with a low number of 'Competitors'. In contrast, it can also identify high-risk "Red Ocean" zones where, despite high demand, the market is oversaturated.
3.  **Algorithmic Reasoning:** The model demonstrates algorithmic reasoning by writing Python logic to handle specific edge cases (e.g., correctly calculating saturation if there are zero competitors). This level of conditional logic and mathematical precision is difficult to achieve with pure text-based prompting but is handled reliably by the Code Execution tool.

**Connecting to the Next Step:**
We now have the Numbers: The analysis identifies the best location mathematically. But business decisions aren't made on numbers alone; they require Nuance.

The next logical step is to explore the qualitative aspects of the top-ranked location, such as:

"What is the specific customer persona for this area?"
"What are the specific risks of opening a business here?"
"What is a viable mitigation strategy for those risks?"

We need to synthesize these cold, hard numbers into a persuasive **Strategic Narrative**.
In **Part 3**, we will switch from "Calculator Mode" (Code Execution) to "Deep Thinking Mode" (Extended Reasoning) to build the final business case.

## PART 3: Final Recommendation with Extended Reasoning

![](https://storage.googleapis.com/github-repo/generative-ai/gemini3/assets/location_finder_04.png)

### The Goal: The "CEO Moment"
We have gathered intelligence (Part 1), mapped the battlefield (Part 2A), and crunched the numbers (Part 2B).
Now, we must answer the ultimate question: **"So, what is the single best move?"**

This is not about listing facts anymore. It is about **Strategic Synthesis**. We need an AI that can weigh conflicting evidence (e.g., "High demand but high rent" vs. "Low rent but low visibility") and make a definitive, justified recommendation.

### The Technical Challenge: Complexity & consistency
1.  **Hallucination Risk:** In complex reasoning tasks, models often "forget" the specific numbers calculated earlier (e.g., recommending a zone that Part 2 proved was saturated).
2.  **Downstream Automation:** We need the output to be computer-readable (JSON) so we can generate a website in Part 4. Generating code directly from large blocks of unorganized text is not feasible.

### The Solution: Extended Reasoning & Structured Output
We leverage two flagship capabilities of Gemini 3:
1.  **Extended Reasoning (Thinking Mode):** We enable `thinking_level="HIGH"`. This forces the model to pause and "think" (generate an internal chain-of-thought) before answering. It critiques its own logic, checks against the Part 3 math, and formulates a robust argument.
2.  **Structured Output (Pydantic):** We define a strict Python schema (`LocationIntelligenceReport`). The model *must* return data that perfectly matches this structure, ensuring reliable JSON for the next steps.

**What we will do:**
1.  **Define the Schema:** Create complex Pydantic classes to model our ideal report.
2.  **Synthesize:** Feed *all* previous data (Parts 1-2) into the model.
3.  **Reason & Decide:** Watch the model "think" through the options and output a final, structured strategic plan.

![](https://storage.googleapis.com/github-repo/generative-ai/gemini3/assets/location_finder_08.png)

### Step 1: Define the Output Structure (Schema)
To ensure our AI consultant produces a report we can *use* programmatically, we define a "Contract" using **Pydantic**.
*   Instead of saying "Give me a report," we say "Fill out this exact form."
*   This ensures we get specific fields like `overall_score` (integer), `chain_dominance_pct` (float), and `next_steps` (list of strings).
"""

print("=" * 70)
print("PART 3: FINAL RECOMMENDATION")
print("=" * 70)

# Define structured output schemas with nested complexity


class StrengthAnalysis(BaseModel):
    """Detailed strength with evidence."""

    factor: str
    description: str
    evidence_from_analysis: str


class ConcernAnalysis(BaseModel):
    """Detailed concern with mitigation."""

    risk: str
    description: str
    mitigation_strategy: str


class CompetitionProfile(BaseModel):
    """Competition characteristics in the zone."""

    total_competitors: int
    density_per_km2: float
    chain_dominance_pct: float
    avg_competitor_rating: float
    high_performers_count: int


class MarketCharacteristics(BaseModel):
    """Market fundamentals for the zone."""

    population_density: str
    income_level: str
    infrastructure_access: str
    foot_traffic_pattern: str
    rental_cost_tier: str


class LocationRecommendation(BaseModel):
    """Complete recommendation for a specific location."""

    location_name: str
    area: str
    overall_score: int
    opportunity_type: str
    strengths: list[StrengthAnalysis]
    concerns: list[ConcernAnalysis]
    competition: CompetitionProfile
    market: MarketCharacteristics
    best_customer_segment: str
    estimated_foot_traffic: str
    next_steps: list[str]


class AlternativeLocation(BaseModel):
    """Brief summary of alternative location."""

    location_name: str
    area: str
    overall_score: int
    opportunity_type: str
    key_strength: str
    key_concern: str
    why_not_top: str


class LocationIntelligenceReport(BaseModel):
    """Complete location intelligence analysis report."""

    target_location: str
    business_type: str
    analysis_date: str
    market_validation: str
    total_competitors_found: int
    zones_analyzed: int
    top_recommendation: LocationRecommendation
    alternative_locations: list[AlternativeLocation]
    key_insights: list[str]
    methodology_summary: str


print("‚úÖ Complex nested Pydantic schemas defined")

"""### Step 2: Generate with Deep Reasoning
Now we invoke Gemini 3. Notice the configuration:
*   `thinking_level=types.ThinkingLevel.HIGH`: Activates the extended reasoning engine.
*   `response_schema=LocationIntelligenceReport`: Enforces the Pydantic structure defined above.

**Watch the "Internal Reasoning":**
When the output appears, look for the **üß† Internal Reasoning** section. You will see the thinking logic.
"""

# Final synthesis prompt with all context
final_recommendation_prompt = f"""
Create a comprehensive location intelligence report for opening a {BUSINESS_TYPE} in {TARGET_LOCATION}.

SYNTHESIZE ALL DATA FROM PREVIOUS ANALYSIS:

**PART 1 - MARKET RESEARCH:**
{market_research_findings}

**PART 2 - COMPETITOR MAPPING:**
{competitor_analysis}

**PART 3 - GAP ANALYSIS:**
{gap_analysis}

TASK:

Analyze ALL the data above and provide a complete recommendation with:

1. TOP RECOMMENDATION:
   - Identify the SINGLE BEST location/zone
   - Score it 0-100 based on comprehensive analysis
   - Classify opportunity type (e.g., "Metro First-Mover", "Residential Sticky", "Underserved Premium")
   - Provide 3-4 detailed STRENGTHS with specific evidence from the analysis
   - Provide 2-3 CONCERNS with mitigation strategies
   - Detailed competition profile (density, chain dominance, ratings)
   - Market characteristics (population, income, infrastructure, traffic, rent)
   - Best customer segment to target
   - Foot traffic estimate
   - 3-5 actionable next steps

2. TWO ALTERNATIVE LOCATIONS:
   - Second and third best options
   - Score each 0-100
   - Opportunity type for each
   - Key strength and concern for each
   - Explain WHY each is NOT the top choice

3. KEY INSIGHTS:
   - 3-5 high-level strategic insights from the entire analysis

4. METHODOLOGY:
   - Brief summary of how this analysis was performed

Focus on:
- Optimal balance of low competition and strong market fundamentals
- Clear competitive advantage potential
- Sustainable business viability
- Risk-adjusted opportunity assessment

Be SPECIFIC. Reference actual data from the analysis. Show your reasoning.
Return the complete report in structured JSON format matching the schema.

Current date: {CURRENT_DATE}
"""

# Enable extended reasoning with HIGH thinking level
print(
    f"\nüß† Generating final recommendation for {BUSINESS_TYPE} in {TARGET_LOCATION}..."
)
print("   Using DEEP REASONING mode for comprehensive analysis...")

response = client.models.generate_content(
    model=MODEL_ID,
    contents=final_recommendation_prompt,
    config=types.GenerateContentConfig(
        thinking_config=types.ThinkingConfig(
            thinking_level=types.ThinkingLevel.HIGH,  # Deep reasoning
            include_thoughts=True,  # Show thought process
        ),
        response_mime_type="application/json",
        response_schema=LocationIntelligenceReport,
    ),
)

# Display the reasoning process
print("\n" + "=" * 70)
print("MODEL'S REASONING PROCESS")
print("=" * 70)

for part in response.candidates[0].content.parts:
    if part.thought:
        display(Markdown("### üß† Internal Reasoning"))
        display(Markdown(part.text))
        print("\n" + "=" * 70)

# Parse the structured output
report = response.parsed

print("\n" + "=" * 70)
print("FINAL RECOMMENDATION")
print("=" * 70)

"""### Step 3: The Strategic Decision
Below is the parsed result. Notice how the raw JSON has been rendered into a clean, human-readable format.

**Key Output Features:**
*   **Top Recommendation:** A single, definitive choice with a calculated score.
*   **Evidence-Based:** Every strength cites specific data from previous parts.
*   **Actionable:** It doesn't just analyze; it prescribes.
"""

comp = report.top_recommendation.competition
market = report.top_recommendation.market

strengths_md = ""
for i, strength in enumerate(report.top_recommendation.strengths, 1):
    strengths_md += f"""**{i}. {strength.factor}**
   - {strength.description}
   - *Evidence:* {strength.evidence_from_analysis}\n
"""

concerns_md = ""
for i, concern in enumerate(report.top_recommendation.concerns, 1):
    concerns_md += f"""**{i}. {concern.risk}**
   - {concern.description}
   - *Mitigation:* {concern.mitigation_strategy}\n
"""

alternatives_md = ""
for alt in report.alternative_locations:
    alternatives_md += f"""
### {alt.location_name} ({alt.area})
- **Score:** {alt.overall_score}/100
- **Type:** {alt.opportunity_type}
- **Strength:** {alt.key_strength}
- **Concern:** {alt.key_concern}
- **Why Not Top:** {alt.why_not_top}
"""

next_steps_md = ""
for i, step in enumerate(report.top_recommendation.next_steps, 1):
    next_steps_md += f"{i}. {step}\n"

key_insights_md = ""
for insight in report.key_insights:
    key_insights_md += f"- {insight}\n"

markdown_content = f"""
## Executive Summary
**Location:** {report.target_location}
**Business:** {report.business_type}
**Analysis Date:** {report.analysis_date}

**Market Validation:** {report.market_validation}
**Analysis Scope:** {report.total_competitors_found} competitors analyzed across {report.zones_analyzed} zones

## üèÜ Top Recommendation
### {report.top_recommendation.location_name}
**Area:** {report.top_recommendation.area}
**Overall Score:** {report.top_recommendation.overall_score}/100
**Opportunity Type:** {report.top_recommendation.opportunity_type}
**Target Segment:** {report.top_recommendation.best_customer_segment}

#### Strengths:
{strengths_md}
#### Concerns:
{concerns_md}
#### Competition Profile:
- **Total Competitors:** {comp.total_competitors}
- **Density:** {comp.density_per_km2:.2f} competitors/km¬≤
- **Chain Dominance:** {comp.chain_dominance_pct:.1f}%
- **Avg Rating:** {comp.avg_competitor_rating:.2f} ‚≠ê
- **High Performers (4.5+):** {comp.high_performers_count}

#### Market Characteristics:
- **Population Density:** {market.population_density}
- **Income Level:** {market.income_level}
- **Infrastructure:** {market.infrastructure_access}
- **Foot Traffic:** {market.foot_traffic_pattern}
- **Rental Costs:** {market.rental_cost_tier}

**Estimated Foot Traffic:** {report.top_recommendation.estimated_foot_traffic}

## Alternative Locations
{alternatives_md}

## üéØ Next Steps
{next_steps_md}

## üí° Key Insights
{key_insights_md}

## Methodology
{report.methodology_summary}
"""

# Display the entire report in one go
display(Markdown(markdown_content))

# Save as JSON
with open("location_intelligence_report.json", "w") as f:
    json.dump(report.model_dump(), f, indent=2)

print("\n‚úÖ Report saved to location_intelligence_report.json")
print("‚úÖ Final recommendation complete")

"""### üß† Analysis of the Reasoning

**What just happened?**
The model successfully synthesized qualitative *Market Trends* (from Part 1), geospatial *Competitor Locations* (from Part 2A), and quantitative *Saturation Metrics* (from Part 2B) into a cohesive business strategy.

**The "Aha!" Moment: The Power of Synthesis**

This is where the model connects all the dots from the previous steps. For example, it might connect:

- A demographic trend from **Part 1** (e.g., a growing population of young professionals in a specific area).
- A geographical gap from **Part 2A** (e.g., a lack of a certain type of business in that same neighborhood).
- A quantitative opportunity from **Part 2B** (e.g., a low market saturation score calculated for that area).
- **Part 3 (Here)** then synthesizes these individual data points into a single, actionable recommendation (e.g., "Open a premium version of the business in that neighborhood to cater to the underserved young professional demographic").

This is **Strategic Intelligence** in action. The model doesn't just summarize the data; it identifies a market gap that a human analyst might have missed while looking at disconnected spreadsheets and reports.

**Connecting to the Final Step:**
We now have the *Strategy* in a structured JSON format. But a JSON file isn't something you present to a Board of Directors. They want a **Presentation/Slide Deck**.
In the final section (**Part 4**), we will ask Gemini to act as a "Frontend Developer" and autonomously convert this JSON data into a stunning, interactive HTML presentation.

## PART 4: Executive Report Generation

![](https://storage.googleapis.com/github-repo/generative-ai/gemini3/assets/location_finder_05.png)

### The Goal: From "Raw Data" to "Client Deliverable"
We have successfully identified the perfect location (*Seegehalli*) and backed it up with math and strategy. But a JSON file is not a deliverable. You cannot present a JSON object to a Board of Directors or an Investor.
We need a **Professional Slide Deck**.

### The Technical Challenge: The "Last Mile" Problem
Typically, turning data into a presentation is a manual, tedious process:
1.  Copy-paste data from Excel to PowerPoint.
2.  Manually adjust fonts, colors, and layout.
3.  Repeat every time the data changes.

### The Solution: Code Generation (HTML/CSS)
We treat the "Presentation" as a "Software Problem." We ask Gemini 3 to act as a **Frontend Developer + UI Designer**.
Instead of using a drag-and-drop tool, we instruct the model to **write the code** for a fully interactive, self-contained HTML website that acts as a slide deck.

**The Architecture:**
1.  **Data Aggregation:** We collect the "Top Recommendation," "Competitor Stats," and "Market Metrics" from our previous steps.
2.  **Design Prompting:** We give Gemini a "Design System" prompt (e.g., "Use a McKinsey/BCG aesthetic," "Navy Blue color palette," "Card-based layout").
3.  **Autonomous Coding:** Gemini writes the full HTML structure and embedded CSS styles from scratch.

**What we will do:**
We will execute a single prompt that transforms our raw analysis into a polished, 7-slide executive presentation‚Äîinstantly.

### Step 1: Format the Context

We gather the specific insights generated in Parts 1 through 3‚Äîthe "Top Recommendation," the "Viability Score," the "Competitor Counts"‚Äîand bundle them into a clean context object. This ensures the report is populated with our actual findings, not placeholder text.

We structure this data into a clear, readable format for the model. Think of this as writing a creative brief for a designer: *"Here are the facts. Now make them look good."*
"""

# @title
print("=" * 70)
print("PART 4: EXECUTIVE REPORT GENERATION")
print("=" * 70)

# Create comprehensive structured data for HTML generation
print("\nüìã Formatting comprehensive data context for HTML generation...")

# Generate the dynamic parts of the report using list comprehensions, accessing the report object directly.
strengths_section = "\n".join(
    [
        f"{i}. {s.factor}\n   Description: {s.description}\n   Evidence: {s.evidence_from_analysis}"
        for i, s in enumerate(report.top_recommendation.strengths, 1)
    ]
)

concerns_section = "\n".join(
    [
        f"{i}. Risk: {c.risk}\n   Description: {c.description}\n   Mitigation: {c.mitigation_strategy}"
        for i, c in enumerate(report.top_recommendation.concerns, 1)
    ]
)

alternatives_section = "\n\n".join(
    [
        f"ALTERNATIVE {i}: {alt.location_name}\nArea: {alt.area}\nScore: {alt.overall_score}/100\nOpportunity Type: {alt.opportunity_type}\nKey Strength: {alt.key_strength}\nKey Concern: {alt.key_concern}\nWhy Not Top Choice: {alt.why_not_top}"
        for i, alt in enumerate(report.alternative_locations, 1)
    ]
)

next_steps_section = "\n".join(
    [f"{i}. {step}" for i, step in enumerate(report.top_recommendation.next_steps, 1)]
)

key_insights_section = "\n".join(
    [f"{i}. {insight}" for i, insight in enumerate(report.key_insights, 1)]
)

# For readability in the f-string, create a few aliases for nested objects
top_rec = report.top_recommendation
comp = top_rec.competition
market = top_rec.market

# Build the final data_context string using a single f-string, accessing the report object directly
data_context = f"""
LOCATION INTELLIGENCE REPORT - COMPREHENSIVE DATA
{"=" * 80}

ANALYSIS OVERVIEW:
- Target Location: {report.target_location}
- Business Type: {report.business_type}
- Analysis Date: {report.analysis_date}
- Market Validation: {report.market_validation}
- Total Competitors Found: {report.total_competitors_found}
- Zones Analyzed: {report.zones_analyzed}

{"=" * 80}
TOP RECOMMENDATION (PRIMARY - SHOW PROMINENTLY ON SLIDE 1)
{"=" * 80}

Location: {top_rec.location_name}
Area: {top_rec.area}
Overall Score: {top_rec.overall_score}/100
Opportunity Type: {top_rec.opportunity_type}
Target Customer Segment: {top_rec.best_customer_segment}
Estimated Foot Traffic: {top_rec.estimated_foot_traffic}

KEY STRENGTHS:
{strengths_section}

CONCERNS & MITIGATION:
{concerns_section}

{"=" * 80}
COMPETITION ANALYSIS
{"=" * 80}

Total Competitors in Zone: {comp.total_competitors}
Competitor Density: {comp.density_per_km2:.2f} competitors/km¬≤
Chain Dominance: {comp.chain_dominance_pct:.1f}%
Average Competitor Rating: {comp.avg_competitor_rating:.2f} ‚≠ê
High-Performing Competitors (4.5+ rating): {comp.high_performers_count}

{"=" * 80}
MARKET CHARACTERISTICS
{"=" * 80}

Population Density: {market.population_density}
Income Level: {market.income_level}
Infrastructure Access: {market.infrastructure_access}
Foot Traffic Pattern: {market.foot_traffic_pattern}
Rental Cost Tier: {market.rental_cost_tier}

{"=" * 80}
ALTERNATIVE LOCATIONS
{"=" * 80}

{alternatives_section}

{"=" * 80}
NEXT STEPS (ACTIONABLE)
{"=" * 80}

{next_steps_section}

{"=" * 80}
KEY STRATEGIC INSIGHTS
{"=" * 80}

{key_insights_section}

{"=" * 80}
METHODOLOGY
{"=" * 80}

{report.methodology_summary}

{"=" * 80}
"""

print("‚úÖ Comprehensive data context formatted")
print(f"   ‚Ä¢ Total context length: {len(data_context):,} characters")
print(
    "   ‚Ä¢ Includes: Executive summary, top recommendation, competition, market, alternatives, insights, next steps"
)

"""### Step 2: The "Designer" Prompt
Now comes the magic. We prompt Gemini 3 with a dual role:
1.  **The Developer:** "Write valid, bug-free HTML5 and CSS3."
2.  **The Designer:** "Use a professional 'Consulting' aesthetic. Use shadows for depth. Use a grid for layout."

Notice that we don't write a single line of HTML ourselves. The model is responsible for the entire DOM structure and Styling.
"""

# @title
# Comprehensive prompt for multi-slide HTML generation
html_generation_prompt = f"""
Generate a comprehensive, professional HTML report for a location intelligence analysis.

This report should be in the style of McKinsey/BCG consulting presentations:
- Multi-slide format using full-screen scrollable sections
- Modern, clean, executive-ready design
- Data-driven visualizations
- Professional color scheme and typography

CRITICAL REQUIREMENTS:

1. STRUCTURE - Create 7 distinct slides (full-screen sections):

   SLIDE 1 - EXECUTIVE SUMMARY & TOP RECOMMENDATION
   - Large, prominent display of recommended location and score
   - Business type and target location
   - High-level market validation
   - Eye-catching hero section

   SLIDE 2 - TOP RECOMMENDATION DETAILS
   - All strengths with evidence (cards/boxes)
   - All concerns with mitigation strategies
   - Opportunity type and target customer segment

   SLIDE 3 - COMPETITION ANALYSIS
   - Competition metrics (total competitors, density, chain dominance)
   - Visual representation of key numbers (large stat boxes)
   - Average ratings, high performers count

   SLIDE 4 - MARKET CHARACTERISTICS
   - Population density, income level, infrastructure
   - Foot traffic patterns, rental costs
   - Grid/card layout for each characteristic

   SLIDE 5 - ALTERNATIVE LOCATIONS
   - Each alternative in a comparison card
   - Scores, opportunity types, strengths/concerns
   - Why each is not the top choice

   SLIDE 6 - KEY INSIGHTS & NEXT STEPS
   - Strategic insights (bullet points or cards)
   - Actionable next steps (numbered list)

   SLIDE 7 - METHODOLOGY
   - How the analysis was performed
   - Data sources and approach

2. DESIGN:
   - Use professional consulting color palette:
     * Primary: Navy blue (#1e3a8a, #3b82f6) for headers/trust
     * Success: Green (#059669, #10b981) for positive metrics
     * Warning: Amber (#d97706, #f59e0b) for concerns
     * Neutral: Grays (#6b7280, #e5e7eb) for backgrounds
   - Modern sans-serif fonts (system: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto)
   - Cards with subtle shadows and rounded corners
   - Generous white space and padding
   - Responsive grid layouts

3. TECHNICAL:
   - Self-contained: ALL CSS embedded in <style> tag
   - No external dependencies (no CDNs, no external images)
   - Each slide: min-height: 100vh; page-break-after: always;
   - Smooth scroll behavior
   - Print-friendly

4. DATA TO INCLUDE (use EXACTLY this data, do not invent):

{data_context}

5. OUTPUT:
   - Generate ONLY the complete HTML code
   - Start with <!DOCTYPE html>
   - End with </html>
   - NO explanations before or after the HTML
   - NO markdown code fences

Make it visually stunning, data-rich, and executive-ready.

Current date: {CURRENT_DATE}
"""

# Generate the comprehensive HTML report
print("\nüé® Generating comprehensive multi-slide HTML report...")
print("   This may take 30-60 seconds due to the complexity...")

response = client.models.generate_content(
    model=MODEL_ID,
    contents=html_generation_prompt,
    config=types.GenerateContentConfig(temperature=1.0),
)

# Extract HTML code
html_code = response.text.strip("```").strip("html").strip()

print(f"‚úÖ HTML report generated ({len(html_code):,} characters)")
print("   Multi-slide consulting-style report with all analysis data")

"""### Step 4: The Reveal
We render the generated raw HTML directly in the notebook.
**Scroll through the output below.** This is not a pre-made template. This entire visual interface‚Äîthe colors, the typography, the layout of the data cards‚Äîwas conceived and coded by Gemini 3 in seconds.
"""

# @title
# Display the HTML report in the notebook
print("\nüìä Displaying executive report...\n")
display(HTML(html_code))

# Save the HTML to a file
report_filename = "location_intelligence_executive_report.html"
with open(report_filename, "w", encoding="utf-8") as f:
    f.write(html_code)

print(f"\n{'=' * 70}")
print(f"‚úÖ Executive report saved to {report_filename}")
print("‚úÖ Open the file in a browser to view the full multi-slide presentation")
print(f"{'=' * 70}")

"""### üé® Analysis of the Output

**What just happened?**
You have just witnessed **End-to-End Autonomous Intelligence**.
*   We started with a vague request: *"I want to open a fitness studio in KR Puram."*
*   We ended with a fully coded, deployment-ready website presenting a mathematically validated strategy.

**Key Capabilities Demonstrated:**
1.  **Cross-Domain Competence:** The same model that performed *Geospatial Analysis* (Part 2A) and *Mathematical Gap Analysis* (Part 2B) just demonstrated *UI/UX Design Principles* (Part 4).
2.  **Data Fidelity:** Check the analysis on Slide 3 ("Competition Analysis"). They match exactly with our Python output from Part 2B. The model successfully maintained data integrity across the entire pipeline.
3.  **No-Code Creativity:** You, the user, didn't need to know `<div>` tags or CSS `flexbox`. You simply described the **outcome** you wanted, and the model handled the implementation.

## Bonus üéâ

Let's generate an infographic with Nano Banana Pro!! üçå

This model is a powerful, generalist multimodal model that offers state-of-the-art image generation and conversational image editing capabilities. Nano Banana Pro is also able to show its work, allowing you to see the 'thought process' behind the generated output.

**NOTE:** Expect higher latency when using this model compared to Gemini 2.5 Flash Image (Nano Banana) as a result of the more advanced capabilities.
"""

MODEL_ID = "gemini-3-pro-image-preview"

prompt = f"""
Generate an infographic for the following report

{data_context}
"""
response = client.models.generate_content(
    model=MODEL_ID,
    contents=prompt,
    config=types.GenerateContentConfig(
        response_modalities=["IMAGE", "TEXT"],
        image_config=types.ImageConfig(
            aspect_ratio="16:9",
        ),
    ),
)

# Check for errors if an image is not generated
if response.candidates[0].finish_reason != types.FinishReason.STOP:
    reason = response.candidates[0].finish_reason
    raise ValueError(f"Prompt Content Error: {reason}")

for part in response.candidates[0].content.parts:
    if part.thought:
        continue  # Skip displaying thoughts
    if part.inline_data:
        display(Image(data=part.inline_data.data, width=1000))

"""Exceptional execution by Nano Banana Pro. The leap in quality, high-resolution output, is immediately apparent. This is a powerful tool that sets a new standard for image generation üöÄ

Check out this [notebook](https://github.com/GoogleCloudPlatform/generative-ai/blob/main/gemini/getting-started/intro_gemini_3_image_gen.ipynb) for more Nano Banana Pro!

## Conclusion: The Future of AI

This notebook demonstrated that **Gemini 3 is not just a model; it can act as an orchestrator.**
By chaining together distinct cognitive capabilities, we built a sophisticated "Virtual Employee" that can:
*   üëÄ **See** the market (Search Grounding)
*   üó∫Ô∏è **Map** the territory (Function Calling)
*   üßÆ **Calculate** the odds (Code Execution)
*   üß† **Strategize** the move (Extended Reasoning)
*   üé® **Pitch** the result (Code and Image Generation)

**Where to go from here?**
*   **Scale it:** Wrap this notebook in a `module` to analyze the location in a single go.
*   **Deepen it:** Add a "Rental Price Scraper" tool to get exact lease costs.
*   **Broaden it:** Adapt the prompts to analyze "Coffee Shops in London" or "Warehouses in Texas."

The architecture remains the same. The world is your dataset.

### Try It Yourself!

**Experiment with different locations:**
```python
TARGET_LOCATION = "Shibuya, Tokyo, Japan"
TARGET_LOCATION = "Austin, Texas, USA"
TARGET_LOCATION = "Shoreditch, London, UK"
```

**Experiment with different business types:**
```python
BUSINESS_TYPE = "fitness studio"
BUSINESS_TYPE = "fast-casual restaurant"
BUSINESS_TYPE = "bookstore cafe"
```

The notebook adapts to any combination!

### Additional Resources

- [Gemini 3 Documentation](https://ai.google.dev/gemini-api/docs)
- [Google Maps Places API](https://developers.google.com/maps/documentation/places/web-service/overview)
- [Vertex AI Pricing](https://cloud.google.com/vertex-ai/pricing)
- [Prompt Engineering Guide](https://ai.google.dev/gemini-api/docs/prompting-intro)
"""